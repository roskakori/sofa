<TABLE BORDER=0 CELLSPACING=5 CELLPADDING=5 COLS=1 WIDTH="100%" BGCOLOR="#3366FF" NOSAVE >
<TR NOSAVE>
<TD NOSAVE>
<CENTER><FONT COLOR="#FFFFFF" SIZE=+3><B>The <TT>compile</TT> command</B></FONT></CENTER>
</TD>
</TR>
</TABLE>

<BR><BR><BR>

<TABLE BORDER=0 COLS=1 WIDTH="100%" BGCOLOR="#3366FF" NOSAVE >
<TR NOSAVE>
<TD NOSAVE><FONT COLOR="#FFFFFF" SIZE="+2">Usage</FONT></TD>
</TR>
</TABLE>
<P>
<TT>compile [-clean] [-verbose] [<A HREF="compile_to_c.html">
compile_to_c_options</A>] &lt;Root-Class&gt;
[&lt;Root-Procedure&gt;]</TT>
</P><P>
Command <TT>compile</TT> is the SmallEiffel compiler.
<BR>
Source code is Eiffel and target code is ANSI C code.
</P><P>
Command <TT>compile</TT> executes in two major steps:
<TABLE BORDER="0"><TR><TD VALIGN="top">
<FONT COLOR="#a000a0"><B>Step&nbsp;1&nbsp;-</B></FONT></TD><TD>command <TT>compile_to_c</TT> is called to produce various
           C files (*.h and *.c). A script file is also produced
           by command <TT>compile_to_c</TT>. The name of the script file
           is also printed by command <TT>compile_to_c</TT> (*.make on
           Unix or *.BAT on DOS for example).
</TD></TR><TR><TD VALIGN="top">
<FONT COLOR="#a000a0"><B>Step&nbsp;2&nbsp;-</B></FONT></TD><TD>The script file produced during
           step 1 is runned, launching the C compilation and linking of
           all the C files produced during the previous step .
</TD></TR>
</TABLE>
</P><P>
Thus, command <TT>compile</TT> is a simple launcher used to sequentially
call command <A HREF="compile_to_c.html"><TT>compile_to_c</TT></A>,
the C compiler and the linker.
</P><P>
Like command <TT>compile_to_c</TT>, command <TT>compile</TT> must have at least
one argument to indicate the starting execution point of the system.
Thus execution will start in <I>&lt;Root-Procedure&gt;</I> of <I>&lt;Root-Class&gt;</I>.
The default <I>&lt;Root-Procedure&gt;</I> is <I>make</I>.
</P>

<TABLE BORDER=0 COLS=1 WIDTH="100%" BGCOLOR="#3366FF" NOSAVE >
<TR NOSAVE>
<TD NOSAVE><FONT COLOR="#FFFFFF" SIZE="+2">Options</FONT></TD>
</TR>
</TABLE>
<P>
<DL COMPACT>
<DT>
<I>-clean</I>:<BR>
<DD> By default, the generated C files and object files are kept from one invocation
   of command <TT>compile</TT>
   to another. This enables incremental C compilation, since only the
   C files which have been modified since the last invocation of
   command <TT>compile</TT> will be recompiled. Because the Eiffel
   to C compilation performed by SmallEiffel is generally much faster
   than the C compilation itself, incremental C compilation saves times.
   However, there are situations where you want to get rid of all
   the previously generated C  and object files, to start afresh.
   This occurs, for example, when you change the C compiler options:
   these new options apply only to the C files which are actually
   recompiled (see example 3 below).<BR>
   Option <I>-clean</I> removes the C and object files previously
   generated by
   making command <TT>clean</TT> be called at the end of the compilation.
<BR><BR>
<DT>

<I>-verbose</I>:<BR>
<DD>
Displays (a lot of) useful information during the compilation (full path of
   loaded files, type inference score, generated files, etc).
</DL>
</P>


<TABLE BORDER=0 COLS=1 WIDTH="100%" BGCOLOR="#3366FF" NOSAVE >
<TR NOSAVE>
<TD NOSAVE><FONT COLOR="#FFFFFF" SIZE="+2">Examples</FONT></TD>
</TR>
</TABLE>

<P>
<FONT COLOR="#FF00FF"><B>Example 1</B></FONT>
<BR>
   When SmallEiffel is correctly installed, you can simply type
   the following command to test the hello world program:
<DL COMPACT><DT><DD><TT>
      compile hello_world
</TT></DL>

   The compiler should tell you what's wrong or should compile
   Eiffel source files telling you the full path used to load
   the Eiffel source code.
<BR>
   Under UNIX, the executable file is named "a.out" by default.
</P><P>

<FONT COLOR="#FF00FF"><B>Example 2</B></FONT>
<BR>
   Type following command to finalize the hello_world simple
   program:
<DL COMPACT><DT><DD><TT>
      compile -boost -no_split -O3 hello_world
</TT></DL>

   Note that option <I>-O3</I> is passed to the C compiler (see the manual
   of your C compiler). Options <I>-boost</I> and <I>-no_split</I>
   are passed to command
<A HREF="compile_to_c.html"><code>compile_to_c</code></A>.
   This is usually the best way to finalize your application.
<BR><BR>
   Only one C file is produced (option <I>-no_split</I>)
</P><P>
<FONT COLOR="#FF00FF"><B>Example 3</B></FONT>
<BR>
   To compile a big project (class PROJECT) with C files splitting and
   require assertions checked:
<DL COMPACT><DT><DD><TT>
      compile -require_check project
</TT></DL>
   The very first time, all C files are produced and compiled.
   Then, if you type the same command after some changes in the
   Eiffel source files, all C files are also produced from scratch.
   If there are only minor changes in the generated
   C files, only modified ones are passed to the C compiler
   (previous object files have been saved).
<BR>
   Keep in mind that C compiler options are not taken into account.
   Thus if you now want to do:
<DL COMPACT><DT><DD><TT>
      compile -require_check project   -O3
</TT></DL>
   You must use the clean command before:
<DL COMPACT><DT><DD><TT>
      clean project
</TT></DL>

   All C files will be then recompiled using the new C option <I>-O3</I>.
   You are thus sure that the new C options are taken into account.
</P>

<!-- BL START -->
<!-- BL1 START -->
<CENTER>
<IMG SRC="se-line.gif" ALT="[Line]">
<BR>
<FONT SIZE="-1"><I>
Copyright &copy; Dominique COLNET and Suzanne COLLIN -
<A HREF="mailto:colnet@loria.fr">&lt;colnet@loria.fr&gt;</A>
<BR>
Last update: 05 June 1999, by DC & OZ.
</I></FONT>
<BR>
</CENTER>
